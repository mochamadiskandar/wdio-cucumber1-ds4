{"info":{"type":"runner","start":"2024-07-05T10:35:37.759Z","end":"2024-07-05T10:35:52.720Z","_duration":14961,"cid":"0-0","capabilities":{"myEdgeBrowser":{"acceptInsecureCerts":false,"browserName":"MicrosoftEdge","browserVersion":"126.0.2592.87","fedcm:accounts":true,"ms:edgeOptions":{"debuggerAddress":"localhost:55634"},"msedge":{"msedgedriverVersion":"126.0.2592.87 (883b9421f9ba9ce195934ad8d16cb5215b659245)","userDataDir":"C:\\Users\\NTT\\AppData\\Local\\Temp\\scoped_dir8672_1899906596"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"windows","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:extension:minPinLength":true,"webauthn:extension:prf":true,"webauthn:virtualAuthenticators":true,"wdio:driverPID":8672,"sessionId":"6f5c76c5b05e3bf29ce97c261d720425"},"myChromeBrowser":{"acceptInsecureCerts":false,"browserName":"chrome","browserVersion":"126.0.6478.127","chrome":{"chromedriverVersion":"126.0.6478.127 (a435861f0ca363a64f7485619ee5939833823fce-refs/branch-heads/6478@{#1592})","userDataDir":"C:\\Users\\NTT\\AppData\\Local\\Temp\\scoped_dir20416_711674876"},"fedcm:accounts":true,"goog:chromeOptions":{"debuggerAddress":"localhost:55636"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"windows","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:extension:minPinLength":true,"webauthn:extension:prf":true,"webauthn:virtualAuthenticators":true,"wdio:driverPID":20416,"sessionId":"12fd08090636a02612ed0354bc725f18"}},"sanitizedCapabilities":"","config":{"isW3C":true,"isChrome":false,"isFirefox":false,"isMobile":false,"isIOS":false,"isAndroid":false,"isSauce":false,"isSeleniumStandalone":false,"isBidi":false,"isChromium":false,"sessionId":"","logLevel":"info","capabilities":{},"protocol":"http","hostname":"0.0.0.0","path":"/"},"specs":["file:///D:/PERSONAL/LEARN/QA/github/wdio-cucumber1-ds4/features/step-definitions/login.feature"],"isMultiremote":true,"instanceOptions":{"6f5c76c5b05e3bf29ce97c261d720425":{"protocol":"http","hostname":"0.0.0.0","path":"/","capabilities":{"browserName":"MicrosoftEdge"},"logLevel":"info","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"enableDirectConnect":true,"strictSSL":true,"cacheDir":"C:\\Users\\NTT\\AppData\\Local\\Temp","port":55623,"requestedCapabilities":{"browserName":"MicrosoftEdge"},"automationProtocol":"webdriver","waitforInterval":500,"waitforTimeout":10000,"onReload":[],"beforeCommand":[],"afterCommand":[],"rootDir":"D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4","specs":["./features/**/*.feature"],"suites":{},"exclude":[],"groupLogsByTestSpec":false,"excludeDriverLogs":[],"bail":0,"framework":"cucumber","reporters":["spec","cucumberjs-json",["html-nice",{"outputDir":"./reports/html/html-report-2024-07-05_17-35-33","filename":"master-report-cb67a19e-59fb-4c99-94f2-2a0a22f0f9b5.html","reportTitle":"master-report-9b89f256-5717-45bb-a9bd-7781f1d50552","browserName":"Chrome & Edge","linkScreenshots":false,"showInBrowser":false,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":[],"maxInstances":5,"maxInstancesPerCapability":100,"injectGlobals":true,"filesToWatch":[],"execArgv":[],"runnerEnv":{},"runner":"local","shard":{"current":1,"total":1},"specFileRetries":0,"specFileRetriesDelay":0,"specFileRetriesDeferred":false,"reporterSyncInterval":100,"reporterSyncTimeout":5000,"cucumberFeaturesWithLineNumbers":[],"autoCompileOpts":{"autoCompile":true,"tsNodeOpts":{"transpileOnly":true},"babelOpts":{}},"mochaOpts":{"timeout":10000},"jasmineOpts":{"defaultTimeoutInterval":10000},"cucumberOpts":{"timeout":60000,"tags":"@login","require":["./features/step-definitions/steps.js"],"backtrace":false,"requireModule":[],"dryRun":false,"failFast":false,"name":[],"snippets":true,"source":true,"strict":false,"tagExpression":"","ignoreUndefinedDefinitions":false},"onPrepare":[],"onWorkerStart":[],"onWorkerEnd":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[null],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[null],"onComplete":[],"beforeAssertion":[],"afterAssertion":[],"beforeFeature":[null],"beforeScenario":[null],"beforeStep":[],"afterStep":[],"afterScenario":[null],"afterFeature":[],"_":["./wdio.conf.js","./wdio.conf.js"],"cucumber-opts":{"tags":"@login"},"$0":"node_modules\\@wdio\\cli\\bin\\wdio.js","ignoredWorkerServices":[]},"12fd08090636a02612ed0354bc725f18":{"protocol":"http","hostname":"0.0.0.0","path":"/","capabilities":{"browserName":"chrome","goog:chromeOptions":{"binary":"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe"}},"logLevel":"info","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"enableDirectConnect":true,"strictSSL":true,"cacheDir":"C:\\Users\\NTT\\AppData\\Local\\Temp","port":55622,"requestedCapabilities":{"browserName":"chrome","goog:chromeOptions":{"binary":"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe"}},"automationProtocol":"webdriver","waitforInterval":500,"waitforTimeout":10000,"onReload":[],"beforeCommand":[],"afterCommand":[],"rootDir":"D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4","specs":["./features/**/*.feature"],"suites":{},"exclude":[],"groupLogsByTestSpec":false,"excludeDriverLogs":[],"bail":0,"framework":"cucumber","reporters":["spec","cucumberjs-json",["html-nice",{"outputDir":"./reports/html/html-report-2024-07-05_17-35-33","filename":"master-report-cb67a19e-59fb-4c99-94f2-2a0a22f0f9b5.html","reportTitle":"master-report-9b89f256-5717-45bb-a9bd-7781f1d50552","browserName":"Chrome & Edge","linkScreenshots":false,"showInBrowser":false,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":[],"maxInstances":5,"maxInstancesPerCapability":100,"injectGlobals":true,"filesToWatch":[],"execArgv":[],"runnerEnv":{},"runner":"local","shard":{"current":1,"total":1},"specFileRetries":0,"specFileRetriesDelay":0,"specFileRetriesDeferred":false,"reporterSyncInterval":100,"reporterSyncTimeout":5000,"cucumberFeaturesWithLineNumbers":[],"autoCompileOpts":{"autoCompile":true,"tsNodeOpts":{"transpileOnly":true},"babelOpts":{}},"mochaOpts":{"timeout":10000},"jasmineOpts":{"defaultTimeoutInterval":10000},"cucumberOpts":{"timeout":60000,"tags":"@login","require":["./features/step-definitions/steps.js"],"backtrace":false,"requireModule":[],"dryRun":false,"failFast":false,"name":[],"snippets":true,"source":true,"strict":false,"tagExpression":"","ignoreUndefinedDefinitions":false},"onPrepare":[],"onWorkerStart":[],"onWorkerEnd":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[null],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[null],"onComplete":[],"beforeAssertion":[],"afterAssertion":[],"beforeFeature":[null],"beforeScenario":[null],"beforeStep":[],"afterStep":[],"afterScenario":[null],"afterFeature":[],"_":["./wdio.conf.js","./wdio.conf.js"],"cucumber-opts":{"tags":"@login"},"$0":"node_modules\\@wdio\\cli\\bin\\wdio.js","ignoredWorkerServices":[]}},"retry":0,"failures":1,"retries":0},"metrics":{"passed":17,"skipped":0,"failed":1,"duration":14961,"start":"2024-07-05T10:35:37.760Z","end":"2024-07-05T10:35:52Z"},"title":"master-report-9b89f256-5717-45bb-a9bd-7781f1d50552","suites":[{"type":"feature","start":"2024-07-05T10:35:37.868Z","end":"2024-07-05T10:35:52.365Z","_duration":14489,"uid":"login.feature:3:1","cid":"0-0","file":"D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\features\\step-definitions\\login.feature","title":"Login","tags":[{"location":{"line":2,"column":1},"name":"@login","id":"13754335-1730-4aae-91fc-39f885e9f8d1"}],"tests":[],"hooks":[],"suites":[{"type":"scenario","start":"2024-07-05T10:35:37.926Z","end":"2024-07-05T10:35:46.234Z","_duration":8306,"uid":"0","cid":"0-0","file":"D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\features\\step-definitions\\login.feature","title":"TC-1 Successful login using valid username","fullTitle":"login.feature:3:1: TC-1 Successful login using valid username","tags":[{"name":"@login","astNodeId":"13754335-1730-4aae-91fc-39f885e9f8d1"},{"name":"@TC1","astNodeId":"0855c486-2247-44f2-96b1-106ee24c7b91"},{"name":"@positive","astNodeId":"383ab31c-5fd1-4025-92bd-5637853d15c3"}],"tests":[{"type":"test","start":"2024-07-05T10:35:37.938Z","end":"2024-07-05T10:35:44.758Z","_duration":6820,"uid":"f640eb2f-58a7-4f65-8a26-33c02fd6aabc","cid":"0-0","title":"Given user already on login page","fullTitle":"0: Given user already on login page","output":[{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:44.758Z","end":"2024-07-05T10:35:45.864Z","_duration":1106,"uid":"0b602272-3475-4f14-97a8-efc91e21799e","cid":"0-0","title":"When user login using \"standard_user\" as username and \"secret_sauce\" as password","fullTitle":"0: When user login using \"standard_user\" as username and \"secret_sauce\" as password","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.3"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.3"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.3/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.3/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.3/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.3/value","body":{"text":"standard_user"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.3/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.3/value","body":{"text":"standard_user"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.3/value","body":{"text":"standard_user"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.3/value","body":{"text":"standard_user"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.4"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.4"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.4/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.4/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.4/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.4/value","body":{"text":"secret_sauce"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.4/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.4/value","body":{"text":"secret_sauce"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.4/value","body":{"text":"secret_sauce"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.4/value","body":{"text":"secret_sauce"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.5"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.5"}},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.5/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.5/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.5/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.5/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.5"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.5"}},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.5/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.5/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.5/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.5/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:45.865Z","end":"2024-07-05T10:35:46.227Z","_duration":362,"uid":"a3861711-1efa-41ad-9c7b-0f8308178583","cid":"0-0","title":"Then user is successfully logged in and redirected to the inventory page","fullTitle":"0: Then user is successfully logged in and redirected to the inventory page","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.25"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.18"}},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.18","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.18"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.25","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.25"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.25","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.25"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.18","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.18"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.25"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.18"}},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.18","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.18"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.25","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.25"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.25","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.25"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.18","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.18"}]},"result":{"value":true},"cid":"0-0","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0}],"hooks":[{"type":"hook","start":"2024-07-05T10:35:37.933Z","end":"2024-07-05T10:35:37.937Z","_duration":4,"uid":"6b6664d9-9371-45fc-b8cf-c5f16d9d2ba9","cid":"0-0","title":"","parent":"0","errors":[]},{"type":"hook","start":"2024-07-05T10:35:46.229Z","end":"2024-07-05T10:35:46.231Z","_duration":2,"uid":"1f16b59f-6b7b-47a9-83a7-dc1752895eb7","cid":"0-0","title":"","parent":"0","errors":[]}],"suites":[],"parent":"login.feature:3:1","hooksAndTests":[{"type":"hook","start":"2024-07-05T10:35:37.933Z","end":"2024-07-05T10:35:37.937Z","_duration":4,"uid":"6b6664d9-9371-45fc-b8cf-c5f16d9d2ba9","cid":"0-0","title":"","parent":"0","errors":[]},{"type":"test","start":"2024-07-05T10:35:37.938Z","end":"2024-07-05T10:35:44.758Z","_duration":6820,"uid":"f640eb2f-58a7-4f65-8a26-33c02fd6aabc","cid":"0-0","title":"Given user already on login page","fullTitle":"0: Given user already on login page","output":[{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:44.758Z","end":"2024-07-05T10:35:45.864Z","_duration":1106,"uid":"0b602272-3475-4f14-97a8-efc91e21799e","cid":"0-0","title":"When user login using \"standard_user\" as username and \"secret_sauce\" as password","fullTitle":"0: When user login using \"standard_user\" as username and \"secret_sauce\" as password","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.3"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.3"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.3/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.3/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.3/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.3/value","body":{"text":"standard_user"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.3/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.3/value","body":{"text":"standard_user"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.3/value","body":{"text":"standard_user"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.3/value","body":{"text":"standard_user"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.4"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.4"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.4/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.4/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.4/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.4/value","body":{"text":"secret_sauce"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.4/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.4/value","body":{"text":"secret_sauce"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.4/value","body":{"text":"secret_sauce"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.4/value","body":{"text":"secret_sauce"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.5"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.5"}},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.5/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.5/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.5/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.5/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.5"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.5"}},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.5/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.5/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.5/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.5/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:45.865Z","end":"2024-07-05T10:35:46.227Z","_duration":362,"uid":"a3861711-1efa-41ad-9c7b-0f8308178583","cid":"0-0","title":"Then user is successfully logged in and redirected to the inventory page","fullTitle":"0: Then user is successfully logged in and redirected to the inventory page","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.25"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.18"}},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.18","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.18"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.25","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.25"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.25","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.25"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.18","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.18"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.25"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.18"}},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.18","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.18"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.25","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.25"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.25","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.1B699E66158D5AAF355162EA8FB0512C.e.25"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.18","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.80B627C6C7C5E1597FB91959D3E62DAA.e.18"}]},"result":{"value":true},"cid":"0-0","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"hook","start":"2024-07-05T10:35:46.229Z","end":"2024-07-05T10:35:46.231Z","_duration":2,"uid":"1f16b59f-6b7b-47a9-83a7-dc1752895eb7","cid":"0-0","title":"","parent":"0","errors":[]}],"description":""},{"type":"scenario","start":"2024-07-05T10:35:46.235Z","end":"2024-07-05T10:35:48.658Z","_duration":2421,"uid":"1","cid":"0-0","file":"D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\features\\step-definitions\\login.feature","title":"TC-1 Successful login using valid username","fullTitle":"login.feature:3:1: TC-1 Successful login using valid username","tags":[{"name":"@login","astNodeId":"13754335-1730-4aae-91fc-39f885e9f8d1"},{"name":"@TC1","astNodeId":"0855c486-2247-44f2-96b1-106ee24c7b91"},{"name":"@positive","astNodeId":"383ab31c-5fd1-4025-92bd-5637853d15c3"}],"tests":[{"type":"test","start":"2024-07-05T10:35:46.237Z","end":"2024-07-05T10:35:47.677Z","_duration":1440,"uid":"ef0aba39-6130-4287-87fd-40a24ce1609d","cid":"0-0","title":"Given user already on login page","fullTitle":"1: Given user already on login page","output":[{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:47.678Z","end":"2024-07-05T10:35:48.373Z","_duration":695,"uid":"3d5d2838-cf32-47d2-bdd4-5f3a733a8d59","cid":"0-0","title":"When user login using \"problem_user\" as username and \"secret_sauce\" as password","fullTitle":"1: When user login using \"problem_user\" as username and \"secret_sauce\" as password","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.32"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.28"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.28/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.32/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.32/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.32/value","body":{"text":"problem_user"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.28/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.28/value","body":{"text":"problem_user"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.32/value","body":{"text":"problem_user"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.28/value","body":{"text":"problem_user"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.29"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.33"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.29/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.33/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.33/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.33/value","body":{"text":"secret_sauce"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.29/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.29/value","body":{"text":"secret_sauce"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.33/value","body":{"text":"secret_sauce"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.29/value","body":{"text":"secret_sauce"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.34"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.30"}},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.30/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.34/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.34/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.30/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.30"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.34"}},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.30/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.34/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.30/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.34/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:48.374Z","end":"2024-07-05T10:35:48.654Z","_duration":280,"uid":"846e4f26-070d-4907-bbf1-25c1daba51b2","cid":"0-0","title":"Then user is successfully logged in and redirected to the inventory page","fullTitle":"1: Then user is successfully logged in and redirected to the inventory page","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.50"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.42"}},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.42","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.42"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.50","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.50"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.50","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.50"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.42","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.42"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.50"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.42"}},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.42","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.42"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.50","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.50"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.50","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.50"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.42","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.42"}]},"result":{"value":true},"cid":"0-0","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0}],"hooks":[{"type":"hook","start":"2024-07-05T10:35:46.235Z","end":"2024-07-05T10:35:46.237Z","_duration":2,"uid":"462b9136-6450-40a5-905f-2da4498eceb6","cid":"0-0","title":"","parent":"1","errors":[]},{"type":"hook","start":"2024-07-05T10:35:48.655Z","end":"2024-07-05T10:35:48.656Z","_duration":1,"uid":"13cb8e29-c5db-448f-af2d-0fd341f05242","cid":"0-0","title":"","parent":"1","errors":[]}],"suites":[],"parent":"login.feature:3:1","hooksAndTests":[{"type":"hook","start":"2024-07-05T10:35:46.235Z","end":"2024-07-05T10:35:46.237Z","_duration":2,"uid":"462b9136-6450-40a5-905f-2da4498eceb6","cid":"0-0","title":"","parent":"1","errors":[]},{"type":"test","start":"2024-07-05T10:35:46.237Z","end":"2024-07-05T10:35:47.677Z","_duration":1440,"uid":"ef0aba39-6130-4287-87fd-40a24ce1609d","cid":"0-0","title":"Given user already on login page","fullTitle":"1: Given user already on login page","output":[{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:47.678Z","end":"2024-07-05T10:35:48.373Z","_duration":695,"uid":"3d5d2838-cf32-47d2-bdd4-5f3a733a8d59","cid":"0-0","title":"When user login using \"problem_user\" as username and \"secret_sauce\" as password","fullTitle":"1: When user login using \"problem_user\" as username and \"secret_sauce\" as password","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.32"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.28"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.28/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.32/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.32/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.32/value","body":{"text":"problem_user"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.28/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.28/value","body":{"text":"problem_user"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.32/value","body":{"text":"problem_user"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.28/value","body":{"text":"problem_user"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.29"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.33"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.29/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.33/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.33/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.33/value","body":{"text":"secret_sauce"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.29/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.29/value","body":{"text":"secret_sauce"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.33/value","body":{"text":"secret_sauce"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.29/value","body":{"text":"secret_sauce"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.34"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.30"}},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.30/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.34/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.34/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.30/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.30"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.34"}},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.30/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.34/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.30/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.34/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:48.374Z","end":"2024-07-05T10:35:48.654Z","_duration":280,"uid":"846e4f26-070d-4907-bbf1-25c1daba51b2","cid":"0-0","title":"Then user is successfully logged in and redirected to the inventory page","fullTitle":"1: Then user is successfully logged in and redirected to the inventory page","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.50"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.42"}},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.42","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.42"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.50","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.50"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.50","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.50"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.42","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.42"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.50"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//span[@data-test='title']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.42"}},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.42","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.42"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.50","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.50"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.50","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.198D81487294801A45BAB9C577579685.e.50"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.42","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.08887E825E149F81B8ABBE1147E1AAB7.e.42"}]},"result":{"value":true},"cid":"0-0","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0},{"type":"hook","start":"2024-07-05T10:35:48.655Z","end":"2024-07-05T10:35:48.656Z","_duration":1,"uid":"13cb8e29-c5db-448f-af2d-0fd341f05242","cid":"0-0","title":"","parent":"1","errors":[]}],"description":""},{"type":"scenario","start":"2024-07-05T10:35:48.659Z","end":"2024-07-05T10:35:49.713Z","_duration":1053,"uid":"2","cid":"0-0","file":"D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\features\\step-definitions\\login.feature","title":"TC-2 Login using lock out username","fullTitle":"login.feature:3:1: TC-2 Login using lock out username","tags":[{"name":"@login","astNodeId":"13754335-1730-4aae-91fc-39f885e9f8d1"},{"name":"@TC2","astNodeId":"291c31c4-c99b-4077-ab08-8802a0c8e663"},{"name":"@negative","astNodeId":"f98a16f3-f27b-49d5-869c-aefb24d129bb"},{"name":"@lockout","astNodeId":"e9b88ff8-e230-44eb-b27c-c9931abe1759"}],"tests":[{"type":"test","start":"2024-07-05T10:35:48.662Z","end":"2024-07-05T10:35:48.865Z","_duration":203,"uid":"254d8789-a73f-4477-a2a2-c9bf455230e2","cid":"0-0","title":"Given user already on login page","fullTitle":"2: Given user already on login page","output":[{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:48.866Z","end":"2024-07-05T10:35:49.600Z","_duration":734,"uid":"19705cbd-909b-4fb8-9b6e-440b37662443","cid":"0-0","title":"When user login using \"locked_out_user\" as username and \"secret_sauce\" as password","fullTitle":"2: When user login using \"locked_out_user\" as username and \"secret_sauce\" as password","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.53"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.48"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.48/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.53/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.53/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.53/value","body":{"text":"locked_out_user"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.48/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.48/value","body":{"text":"locked_out_user"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.53/value","body":{"text":"locked_out_user"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.48/value","body":{"text":"locked_out_user"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.54"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.49"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.49/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.54/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.54/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.54/value","body":{"text":"secret_sauce"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.49/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.49/value","body":{"text":"secret_sauce"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.54/value","body":{"text":"secret_sauce"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.49/value","body":{"text":"secret_sauce"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.55"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.50"}},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.50/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.55/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.55/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.50/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.50"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.55"}},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.50/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.55/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.50/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.55/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:49.601Z","end":"2024-07-05T10:35:49.710Z","_duration":109,"uid":"5cbaa8c8-6d6c-46f9-b67d-cf844505cac9","cid":"0-0","title":"Then error popup displays \"Epic sadface: this user has been locked out.\"","fullTitle":"2: Then error popup displays \"Epic sadface: this user has been locked out.\"","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.64"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.57"}},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.57","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.57"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.64","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.64"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.64","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.64"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.57","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.57"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.57"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.64"}},"cid":"0-0","type":"result"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.57/text","body":{},"cid":"0-0","type":"command"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.64/text","body":{},"cid":"0-0","type":"command"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.64/text","body":{},"result":{"value":"Epic sadface: Sorry, this user has been locked out."},"cid":"0-0","type":"result"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.57/text","body":{},"result":{"value":"Epic sadface: Sorry, this user has been locked out."},"cid":"0-0","type":"result"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0}],"hooks":[{"type":"hook","start":"2024-07-05T10:35:48.659Z","end":"2024-07-05T10:35:48.661Z","_duration":2,"uid":"38824086-854d-4803-a250-9b190cdedbaa","cid":"0-0","title":"","parent":"2","errors":[]},{"type":"hook","start":"2024-07-05T10:35:49.710Z","end":"2024-07-05T10:35:49.711Z","_duration":1,"uid":"99dfab03-1894-41f9-a1ce-05e8eb8dc470","cid":"0-0","title":"","parent":"2","errors":[]}],"suites":[],"parent":"login.feature:3:1","hooksAndTests":[{"type":"hook","start":"2024-07-05T10:35:48.659Z","end":"2024-07-05T10:35:48.661Z","_duration":2,"uid":"38824086-854d-4803-a250-9b190cdedbaa","cid":"0-0","title":"","parent":"2","errors":[]},{"type":"test","start":"2024-07-05T10:35:48.662Z","end":"2024-07-05T10:35:48.865Z","_duration":203,"uid":"254d8789-a73f-4477-a2a2-c9bf455230e2","cid":"0-0","title":"Given user already on login page","fullTitle":"2: Given user already on login page","output":[{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:48.866Z","end":"2024-07-05T10:35:49.600Z","_duration":734,"uid":"19705cbd-909b-4fb8-9b6e-440b37662443","cid":"0-0","title":"When user login using \"locked_out_user\" as username and \"secret_sauce\" as password","fullTitle":"2: When user login using \"locked_out_user\" as username and \"secret_sauce\" as password","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.53"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.48"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.48/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.53/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.53/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.53/value","body":{"text":"locked_out_user"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.48/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.48/value","body":{"text":"locked_out_user"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.53/value","body":{"text":"locked_out_user"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.48/value","body":{"text":"locked_out_user"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.54"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.49"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.49/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.54/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.54/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.54/value","body":{"text":"secret_sauce"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.49/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.49/value","body":{"text":"secret_sauce"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.54/value","body":{"text":"secret_sauce"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.49/value","body":{"text":"secret_sauce"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.55"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.50"}},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.50/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.55/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.55/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.50/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.50"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.55"}},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.50/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.55/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.50/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.55/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:49.601Z","end":"2024-07-05T10:35:49.710Z","_duration":109,"uid":"5cbaa8c8-6d6c-46f9-b67d-cf844505cac9","cid":"0-0","title":"Then error popup displays \"Epic sadface: this user has been locked out.\"","fullTitle":"2: Then error popup displays \"Epic sadface: this user has been locked out.\"","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.64"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.57"}},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.57","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.57"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.64","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.64"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.64","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.64"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.57","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.57"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.57"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.64"}},"cid":"0-0","type":"result"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.57/text","body":{},"cid":"0-0","type":"command"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.64/text","body":{},"cid":"0-0","type":"command"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.2773078808F480E87378C107ED27860C.e.64/text","body":{},"result":{"value":"Epic sadface: Sorry, this user has been locked out."},"cid":"0-0","type":"result"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.B3747E575A4DD3E0F8FA65D984E08A15.e.57/text","body":{},"result":{"value":"Epic sadface: Sorry, this user has been locked out."},"cid":"0-0","type":"result"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0},{"type":"hook","start":"2024-07-05T10:35:49.710Z","end":"2024-07-05T10:35:49.711Z","_duration":1,"uid":"99dfab03-1894-41f9-a1ce-05e8eb8dc470","cid":"0-0","title":"","parent":"2","errors":[]}],"description":""},{"type":"scenario","start":"2024-07-05T10:35:49.714Z","end":"2024-07-05T10:35:50.507Z","_duration":791,"uid":"3","cid":"0-0","file":"D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\features\\step-definitions\\login.feature","title":"TC-3 Login using random username","fullTitle":"login.feature:3:1: TC-3 Login using random username","tags":[{"name":"@login","astNodeId":"13754335-1730-4aae-91fc-39f885e9f8d1"},{"name":"@TC3","astNodeId":"4d5b4cac-3ad7-4d43-8c71-2cf63e08b2e9"},{"name":"@negative","astNodeId":"7cdfe21e-752f-4ec4-88ec-10b0abe0783b"},{"name":"@random","astNodeId":"2f683252-5e57-4372-b895-194be6f2c6b2"}],"tests":[{"type":"test","start":"2024-07-05T10:35:49.716Z","end":"2024-07-05T10:35:49.865Z","_duration":149,"uid":"ebae3b25-527b-462c-a693-21bb816ecbf4","cid":"0-0","title":"Given user already on login page","fullTitle":"3: Given user already on login page","output":[{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"3","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:49.866Z","end":"2024-07-05T10:35:50.370Z","_duration":504,"uid":"02f08d97-7c61-470b-87d8-53c2140ef007","cid":"0-0","title":"When user login using \"1234\" as username and \"abcd\" as password","fullTitle":"3: When user login using \"1234\" as username and \"abcd\" as password","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.68"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.61"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.61/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.68/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.68/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.68/value","body":{"text":"1234"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.61/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.61/value","body":{"text":"1234"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.61/value","body":{"text":"1234"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.68/value","body":{"text":"1234"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.69"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.62"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.62/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.69/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.69/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.69/value","body":{"text":"abcd"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.62/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.62/value","body":{"text":"abcd"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.69/value","body":{"text":"abcd"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.62/value","body":{"text":"abcd"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.63"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.70"}},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.63/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.70/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.63/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.70/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.63"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.70"}},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.63/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.70/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.70/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.63/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"3","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:50.371Z","end":"2024-07-05T10:35:50.503Z","_duration":132,"uid":"a9e07bbd-910c-4bc6-aada-060068f3e813","cid":"0-0","title":"Then error popup displays \"Epic sadface: Username and password do not match any user in this service\"","fullTitle":"3: Then error popup displays \"Epic sadface: Username and password do not match any user in this service\"","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.77"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.73"}},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.73","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.73"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.77","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.77"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.77","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.77"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.73","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.73"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.73"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.77"}},"cid":"0-0","type":"result"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.73/text","body":{},"cid":"0-0","type":"command"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.77/text","body":{},"cid":"0-0","type":"command"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.73/text","body":{},"result":{"value":"Epic sadface: Username and password do not match any user in this service"},"cid":"0-0","type":"result"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.77/text","body":{},"result":{"value":"Epic sadface: Username and password do not match any user in this service"},"cid":"0-0","type":"result"}],"retries":0,"parent":"3","state":"passed","events":[],"errorIndex":0}],"hooks":[{"type":"hook","start":"2024-07-05T10:35:49.714Z","end":"2024-07-05T10:35:49.715Z","_duration":1,"uid":"7ffed3bc-0629-4553-9429-dbeafbaf6e43","cid":"0-0","title":"","parent":"3","errors":[]},{"type":"hook","start":"2024-07-05T10:35:50.504Z","end":"2024-07-05T10:35:50.505Z","_duration":1,"uid":"0c8cf0fd-0cec-4cc7-92d9-e5333819788e","cid":"0-0","title":"","parent":"3","errors":[]}],"suites":[],"parent":"login.feature:3:1","hooksAndTests":[{"type":"hook","start":"2024-07-05T10:35:49.714Z","end":"2024-07-05T10:35:49.715Z","_duration":1,"uid":"7ffed3bc-0629-4553-9429-dbeafbaf6e43","cid":"0-0","title":"","parent":"3","errors":[]},{"type":"test","start":"2024-07-05T10:35:49.716Z","end":"2024-07-05T10:35:49.865Z","_duration":149,"uid":"ebae3b25-527b-462c-a693-21bb816ecbf4","cid":"0-0","title":"Given user already on login page","fullTitle":"3: Given user already on login page","output":[{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"3","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:49.866Z","end":"2024-07-05T10:35:50.370Z","_duration":504,"uid":"02f08d97-7c61-470b-87d8-53c2140ef007","cid":"0-0","title":"When user login using \"1234\" as username and \"abcd\" as password","fullTitle":"3: When user login using \"1234\" as username and \"abcd\" as password","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.68"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.61"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.61/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.68/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.68/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.68/value","body":{"text":"1234"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.61/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.61/value","body":{"text":"1234"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.61/value","body":{"text":"1234"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.68/value","body":{"text":"1234"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.69"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.62"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.62/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.69/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.69/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.69/value","body":{"text":"abcd"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.62/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.62/value","body":{"text":"abcd"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.69/value","body":{"text":"abcd"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.62/value","body":{"text":"abcd"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.63"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.70"}},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.63/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.70/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.63/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.70/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.63"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.70"}},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.63/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.70/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.70/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.63/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"3","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:50.371Z","end":"2024-07-05T10:35:50.503Z","_duration":132,"uid":"a9e07bbd-910c-4bc6-aada-060068f3e813","cid":"0-0","title":"Then error popup displays \"Epic sadface: Username and password do not match any user in this service\"","fullTitle":"3: Then error popup displays \"Epic sadface: Username and password do not match any user in this service\"","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.77"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.73"}},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.73","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.73"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.77","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.77"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.77","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.77"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.73","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.73"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.73"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.77"}},"cid":"0-0","type":"result"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.73/text","body":{},"cid":"0-0","type":"command"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.77/text","body":{},"cid":"0-0","type":"command"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.AF90457ACEE383D419D30BDD2061D074.e.73/text","body":{},"result":{"value":"Epic sadface: Username and password do not match any user in this service"},"cid":"0-0","type":"result"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5CD0F74F4A6FA4974B71123F8FF4B98C.e.77/text","body":{},"result":{"value":"Epic sadface: Username and password do not match any user in this service"},"cid":"0-0","type":"result"}],"retries":0,"parent":"3","state":"passed","events":[],"errorIndex":0},{"type":"hook","start":"2024-07-05T10:35:50.504Z","end":"2024-07-05T10:35:50.505Z","_duration":1,"uid":"0c8cf0fd-0cec-4cc7-92d9-e5333819788e","cid":"0-0","title":"","parent":"3","errors":[]}],"description":""},{"type":"scenario","start":"2024-07-05T10:35:50.507Z","end":"2024-07-05T10:35:51.413Z","_duration":905,"uid":"4","cid":"0-0","file":"D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\features\\step-definitions\\login.feature","title":"TC-3 Login using random username","fullTitle":"login.feature:3:1: TC-3 Login using random username","tags":[{"name":"@login","astNodeId":"13754335-1730-4aae-91fc-39f885e9f8d1"},{"name":"@TC3","astNodeId":"4d5b4cac-3ad7-4d43-8c71-2cf63e08b2e9"},{"name":"@negative","astNodeId":"7cdfe21e-752f-4ec4-88ec-10b0abe0783b"},{"name":"@random","astNodeId":"2f683252-5e57-4372-b895-194be6f2c6b2"}],"tests":[{"type":"test","start":"2024-07-05T10:35:50.510Z","end":"2024-07-05T10:35:50.636Z","_duration":126,"uid":"d0dc07b0-cdf0-4231-839b-844cc7123de2","cid":"0-0","title":"Given user already on login page","fullTitle":"4: Given user already on login page","output":[{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"4","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:50.636Z","end":"2024-07-05T10:35:51.322Z","_duration":686,"uid":"675c1d61-9eca-4ffd-b893-6c0e422327e4","cid":"0-0","title":"When user login using \"loremIpsum\" as username and \"dolorSitAmet\" as password","fullTitle":"4: When user login using \"loremIpsum\" as username and \"dolorSitAmet\" as password","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.81"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.77"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.77/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.81/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.81/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.81/value","body":{"text":"loremIpsum"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.77/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.77/value","body":{"text":"loremIpsum"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.77/value","body":{"text":"loremIpsum"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.81/value","body":{"text":"loremIpsum"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.82"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.78"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.78/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.82/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.78/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.78/value","body":{"text":"dolorSitAmet"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.82/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.82/value","body":{"text":"dolorSitAmet"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.82/value","body":{"text":"dolorSitAmet"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.78/value","body":{"text":"dolorSitAmet"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.83"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.79"}},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.79/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.83/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.83/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.79/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.83"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.79"}},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.79/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.83/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.83/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.79/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"4","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:51.322Z","end":"2024-07-05T10:35:51.410Z","_duration":88,"uid":"5e91d030-029a-4803-9222-5fe793b1449b","cid":"0-0","title":"Then error popup displays \"Epic sadface: Username and password do not match any user in this service\"","fullTitle":"4: Then error popup displays \"Epic sadface: Username and password do not match any user in this service\"","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.90"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.86"}},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.86","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.86"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.90","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.90"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.90","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.90"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.86","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.86"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.90"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.86"}},"cid":"0-0","type":"result"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.86/text","body":{},"cid":"0-0","type":"command"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.90/text","body":{},"cid":"0-0","type":"command"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.86/text","body":{},"result":{"value":"Epic sadface: Username and password do not match any user in this service"},"cid":"0-0","type":"result"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.90/text","body":{},"result":{"value":"Epic sadface: Username and password do not match any user in this service"},"cid":"0-0","type":"result"}],"retries":0,"parent":"4","state":"passed","events":[],"errorIndex":0}],"hooks":[{"type":"hook","start":"2024-07-05T10:35:50.508Z","end":"2024-07-05T10:35:50.509Z","_duration":1,"uid":"c1ea7267-3171-4e41-8858-99efb1a26e21","cid":"0-0","title":"","parent":"4","errors":[]},{"type":"hook","start":"2024-07-05T10:35:51.411Z","end":"2024-07-05T10:35:51.411Z","_duration":0,"uid":"3e6a0f4c-4cae-48b6-af44-d3015dbb3afe","cid":"0-0","title":"","parent":"4","errors":[]}],"suites":[],"parent":"login.feature:3:1","hooksAndTests":[{"type":"hook","start":"2024-07-05T10:35:50.508Z","end":"2024-07-05T10:35:50.509Z","_duration":1,"uid":"c1ea7267-3171-4e41-8858-99efb1a26e21","cid":"0-0","title":"","parent":"4","errors":[]},{"type":"test","start":"2024-07-05T10:35:50.510Z","end":"2024-07-05T10:35:50.636Z","_duration":126,"uid":"d0dc07b0-cdf0-4231-839b-844cc7123de2","cid":"0-0","title":"Given user already on login page","fullTitle":"4: Given user already on login page","output":[{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"4","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:50.636Z","end":"2024-07-05T10:35:51.322Z","_duration":686,"uid":"675c1d61-9eca-4ffd-b893-6c0e422327e4","cid":"0-0","title":"When user login using \"loremIpsum\" as username and \"dolorSitAmet\" as password","fullTitle":"4: When user login using \"loremIpsum\" as username and \"dolorSitAmet\" as password","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.81"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.77"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.77/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.81/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.81/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.81/value","body":{"text":"loremIpsum"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.77/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.77/value","body":{"text":"loremIpsum"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.77/value","body":{"text":"loremIpsum"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.81/value","body":{"text":"loremIpsum"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.82"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.78"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.78/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.82/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.78/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.78/value","body":{"text":"dolorSitAmet"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.82/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.82/value","body":{"text":"dolorSitAmet"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.82/value","body":{"text":"dolorSitAmet"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.78/value","body":{"text":"dolorSitAmet"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.83"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.79"}},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.79/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.83/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.83/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.79/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.83"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.79"}},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.79/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.83/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.83/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.79/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"4","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:51.322Z","end":"2024-07-05T10:35:51.410Z","_duration":88,"uid":"5e91d030-029a-4803-9222-5fe793b1449b","cid":"0-0","title":"Then error popup displays \"Epic sadface: Username and password do not match any user in this service\"","fullTitle":"4: Then error popup displays \"Epic sadface: Username and password do not match any user in this service\"","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.90"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.86"}},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.86","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.86"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.90","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.90"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.90","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.90"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.86","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.86"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.90"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.86"}},"cid":"0-0","type":"result"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.86/text","body":{},"cid":"0-0","type":"command"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.90/text","body":{},"cid":"0-0","type":"command"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.42E867837E1927976684F82BA61778EC.e.86/text","body":{},"result":{"value":"Epic sadface: Username and password do not match any user in this service"},"cid":"0-0","type":"result"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5AC2063AC4C0375806CC2BEE962152B2.e.90/text","body":{},"result":{"value":"Epic sadface: Username and password do not match any user in this service"},"cid":"0-0","type":"result"}],"retries":0,"parent":"4","state":"passed","events":[],"errorIndex":0},{"type":"hook","start":"2024-07-05T10:35:51.411Z","end":"2024-07-05T10:35:51.411Z","_duration":0,"uid":"3e6a0f4c-4cae-48b6-af44-d3015dbb3afe","cid":"0-0","title":"","parent":"4","errors":[]}],"description":""},{"type":"scenario","start":"2024-07-05T10:35:51.413Z","end":"2024-07-05T10:35:52.356Z","_duration":941,"uid":"5","cid":"0-0","file":"D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\features\\step-definitions\\login.feature","title":"TC-4 Login using random username","fullTitle":"login.feature:3:1: TC-4 Login using random username","tags":[{"name":"@login","astNodeId":"13754335-1730-4aae-91fc-39f885e9f8d1"},{"name":"@TC4","astNodeId":"2178daa7-4812-4760-9347-4533aad15363"},{"name":"@intentional-fail","astNodeId":"cb82ed1b-f29c-419f-ae2e-3a0e0596e87e"}],"tests":[{"type":"test","start":"2024-07-05T10:35:51.415Z","end":"2024-07-05T10:35:51.545Z","_duration":130,"uid":"f62f7a7d-8289-47a4-a196-4d35144cb40a","cid":"0-0","title":"Given user already on login page","fullTitle":"5: Given user already on login page","output":[{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"5","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:51.545Z","end":"2024-07-05T10:35:52.123Z","_duration":578,"uid":"47d21d30-14ec-4d57-a008-6cba33b4af1c","cid":"0-0","title":"When user login using \"johndoe\" as username and \"123456\" as password","fullTitle":"5: When user login using \"johndoe\" as username and \"123456\" as password","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.94"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.90"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.90/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.94/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.94/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.94/value","body":{"text":"johndoe"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.90/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.90/value","body":{"text":"johndoe"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.94/value","body":{"text":"johndoe"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.90/value","body":{"text":"johndoe"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.95"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.91"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.91/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.95/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.95/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.95/value","body":{"text":"123456"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.91/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.91/value","body":{"text":"123456"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.95/value","body":{"text":"123456"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.91/value","body":{"text":"123456"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.92"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.96"}},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.92/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.96/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.92/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.96/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.92"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.96"}},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.92/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.96/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.96/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.92/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"5","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:52.124Z","end":"2024-07-05T10:35:52.219Z","_duration":95,"uid":"caaab7aa-a64a-4e8e-9b2e-639f251b4928","cid":"0-0","title":"Then error popup displays \"Kamu belum registrasi bro!\"","fullTitle":"5: Then error popup displays \"Kamu belum registrasi bro!\"","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.103"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.99"}},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.99","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.99"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.103","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.103"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.103","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.103"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.99","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.99"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.103"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.99"}},"cid":"0-0","type":"result"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.99/text","body":{},"cid":"0-0","type":"command"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.103/text","body":{},"cid":"0-0","type":"command"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.103/text","body":{},"result":{"value":"Epic sadface: Username and password do not match any user in this service"},"cid":"0-0","type":"result"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.99/text","body":{},"result":{"value":"Epic sadface: Username and password do not match any user in this service"},"cid":"0-0","type":"result"},{"command":"takeScreenshot","method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"cid":"0-0","type":"command"},{"command":"takeScreenshot","method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"cid":"0-0","type":"command"},{"command":"takeScreenshot","method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"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"},"cid":"0-0","type":"result"},{"command":"takeScreenshot","method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"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JmxKROStzIffumpRyTHriqu++43Ezd6a3Lia3GtVVbwsuHjc49GfDxU9Pr9o3Iqxn+112Y9e+0pzrwUD+C6567PLA1Ndw53kK9el0AXzb2cPQWnbqgueCtErIkNue3v96DXOIiIvVJ7KjjPOlPHXfRtX1/xpXYxxpsiQo/13HfrVUZ6rqjNNncWGfffGDf/XVdFqW+YoCU6plquv+64//9Pl8lrEM295LuLOiQ1URKT/ZPUJXXr0ZyXBKdXjrjoXkXEXfV993Xf1Cb/00M5JDp+MFTzQ21bXPXt18ImR674nGvv4675dttYtL2XX2D2308uPHndklIu+8d0TFpsQor9yEV+ugFui50T7Xfq7p7qKOwmZ8sbc/kz5LTF8l5/xbPWjARcAgGmOTHmjmPvGbVFTmt121bmVbutUFQMAAG43MiVui2vdig8AAHxrcS8hAAAAaEWmBAAAgFZkSgAAAGhFpgQAAIBWZEoAAABoRaYEAACAVmRKAAAAaEWmBAAAgFZkSgAAAGhFpgQAAIBWZEoAAABoRaacZra2Oq02p9XmNFcmamzqBZPN2lqhoYFMU6eztURjFQAA4LuATDnN1JVk5GZn1HWrgcHRU13L7bR25zslWkMzAACYNsiU00yXubGpufEj1+BUF3JbGfOWPBkaNHuqywAAALcKmfKOEZtnOtVhc1ptzrPdp0z5sWNrYopNZttZm9Nqc542786L+dqmQZmmTueZ1qplQcMLjKlV73d6Jtk/MZuKF4175hsjTVkaFnz/Osoypla93/mJZ5P21qrk4S6umjevaLXZTOkiIlJyzGo7tTpM0UUVe2b5J51e39rq7DBljjy6omVj+jvmkYG0t5SODURi80ynTnt2V+exbanG4cXpuzuGTy0o3XncabU5rZ27X7iOYQIAAK9mTHUBuD4vmKpWz7u4vyxjf68EPL5+TXqVybEopdoukvLG1swIaasrMp12GRfnrF+9defZyFVNo1sGZZqaiyP6Tevisg55lsTsfLvoyRmWmuL6E+6gxWvSM0tN5+anVIpEb67euEh/eldRtaepxTqxeS8rquL1/ERDd83mXSfc+gVJa1MKqis+He3ommoLcy36J3KqfuqsLN71FxFxW296r6RtWhur66spfvOEO2jZurVpeSWVh/LtIsashrdXB9ubyjKO9s6au2L9c/m/V62PbrSI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MiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQDMoh0ZAAADFklEQVQAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAA4P9vt44FAAAAAAb5Ww9ib1F0OSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAFeKcpqjyLmifwAAAABJRU5ErkJggg=="},"cid":"0-0","type":"result"},{"command":"deleteSession","method":"DELETE","endpoint":"/session/:sessionId","body":{},"cid":"0-0","type":"command"},{"command":"deleteSession","method":"DELETE","endpoint":"/session/:sessionId","body":{},"cid":"0-0","type":"command"},{"command":"deleteSession","method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"deleteSession","method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"5","state":"failed","errors":[{"name":"Error","message":"Error: \u001b[2mexpect(\u001b[22m\u001b[31mreceived\u001b[39m\u001b[2m).\u001b[22mtoBe\u001b[2m(\u001b[22m\u001b[32mexpected\u001b[39m\u001b[2m) // Object.is equality\u001b[22m","stack":"Error: \u001b[2mexpect(\u001b[22m\u001b[31mreceived\u001b[39m\u001b[2m).\u001b[22mtoBe\u001b[2m(\u001b[22m\u001b[32mexpected\u001b[39m\u001b[2m) // Object.is equality\u001b[22m\n\nExpected: \u001b[32m\"Kamu belum registrasi bro!\"\u001b[39m\nReceived: \u001b[31m\"Epic sadface: Username and password do not match any user in this service\"\u001b[39m\n    at LoginPage.validateErrorPopUpMessage (file:///D:/PERSONAL/LEARN/QA/github/wdio-cucumber1-ds4/features/pageobjects/login.page.js:43:41)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async World.<anonymous> (file:///D:/PERSONAL/LEARN/QA/github/wdio-cucumber1-ds4/features/step-definitions/steps.js:44:5)\n    at async wrapPromiseWithTimeout (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\time.js:57:12)\n    at async Object.run (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\user_code_runner.js:64:22)\n    at async Object.run (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\step_runner.js:51:26)\n    at async TestCaseRunner.invokeStep (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:95:16)\n    at async TestCaseRunner.runStep (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:244:26)\n    at async D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:175:44\n    at async TestCaseRunner.aroundTestStep (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:120:32)"}],"error":{"name":"Error","message":"Error: \u001b[2mexpect(\u001b[22m\u001b[31mreceived\u001b[39m\u001b[2m).\u001b[22mtoBe\u001b[2m(\u001b[22m\u001b[32mexpected\u001b[39m\u001b[2m) // Object.is equality\u001b[22m","stack":"Error: \u001b[2mexpect(\u001b[22m\u001b[31mreceived\u001b[39m\u001b[2m).\u001b[22mtoBe\u001b[2m(\u001b[22m\u001b[32mexpected\u001b[39m\u001b[2m) // Object.is equality\u001b[22m\n\nExpected: \u001b[32m\"Kamu belum registrasi bro!\"\u001b[39m\nReceived: \u001b[31m\"Epic sadface: Username and password do not match any user in this service\"\u001b[39m\n    at LoginPage.validateErrorPopUpMessage (file:///D:/PERSONAL/LEARN/QA/github/wdio-cucumber1-ds4/features/pageobjects/login.page.js:43:41)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async World.<anonymous> (file:///D:/PERSONAL/LEARN/QA/github/wdio-cucumber1-ds4/features/step-definitions/steps.js:44:5)\n    at async wrapPromiseWithTimeout (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\time.js:57:12)\n    at async Object.run (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\user_code_runner.js:64:22)\n    at async Object.run (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\step_runner.js:51:26)\n    at async TestCaseRunner.invokeStep (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:95:16)\n    at async TestCaseRunner.runStep (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:244:26)\n    at async D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:175:44\n    at async TestCaseRunner.aroundTestStep (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:120:32)"},"events":[{"type":"Error","value":{"name":"Error","message":"Error: \u001b[2mexpect(\u001b[22m\u001b[31mreceived\u001b[39m\u001b[2m).\u001b[22mtoBe\u001b[2m(\u001b[22m\u001b[32mexpected\u001b[39m\u001b[2m) // Object.is equality\u001b[22m","stack":"Error: \u001b[2mexpect(\u001b[22m\u001b[31mreceived\u001b[39m\u001b[2m).\u001b[22mtoBe\u001b[2m(\u001b[22m\u001b[32mexpected\u001b[39m\u001b[2m) // Object.is equality\u001b[22m\n\nExpected: \u001b[32m\"Kamu belum registrasi bro!\"\u001b[39m\nReceived: \u001b[31m\"Epic sadface: Username and password do not match any user in this service\"\u001b[39m\n    at LoginPage.validateErrorPopUpMessage (file:///D:/PERSONAL/LEARN/QA/github/wdio-cucumber1-ds4/features/pageobjects/login.page.js:43:41)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async World.<anonymous> (file:///D:/PERSONAL/LEARN/QA/github/wdio-cucumber1-ds4/features/step-definitions/steps.js:44:5)\n    at async wrapPromiseWithTimeout (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\time.js:57:12)\n    at async Object.run (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\user_code_runner.js:64:22)\n    at async Object.run (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\step_runner.js:51:26)\n    at async TestCaseRunner.invokeStep (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:95:16)\n    at async TestCaseRunner.runStep (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:244:26)\n    at async D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:175:44\n    at async TestCaseRunner.aroundTestStep (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:120:32)"}}],"errorIndex":1}],"hooks":[{"type":"hook","start":"2024-07-05T10:35:51.414Z","end":"2024-07-05T10:35:51.414Z","_duration":0,"uid":"6a2e685a-132d-46c8-bdac-af42dee21b4a","cid":"0-0","title":"","parent":"5","errors":[]},{"type":"hook","start":"2024-07-05T10:35:52.220Z","end":"2024-07-05T10:35:52.354Z","_duration":134,"uid":"b799f342-2723-4767-989b-035ecf8f8e2b","cid":"0-0","title":"","parent":"5","errors":[]}],"suites":[],"parent":"login.feature:3:1","hooksAndTests":[{"type":"hook","start":"2024-07-05T10:35:51.414Z","end":"2024-07-05T10:35:51.414Z","_duration":0,"uid":"6a2e685a-132d-46c8-bdac-af42dee21b4a","cid":"0-0","title":"","parent":"5","errors":[]},{"type":"test","start":"2024-07-05T10:35:51.415Z","end":"2024-07-05T10:35:51.545Z","_duration":130,"uid":"f62f7a7d-8289-47a4-a196-4d35144cb40a","cid":"0-0","title":"Given user already on login page","fullTitle":"5: Given user already on login page","output":[{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://www.saucedemo.com/"},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"5","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:51.545Z","end":"2024-07-05T10:35:52.123Z","_duration":578,"uid":"47d21d30-14ec-4d57-a008-6cba33b4af1c","cid":"0-0","title":"When user login using \"johndoe\" as username and \"123456\" as password","fullTitle":"5: When user login using \"johndoe\" as username and \"123456\" as password","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.94"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='user-name']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.90"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.90/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.94/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.94/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.94/value","body":{"text":"johndoe"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.90/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.90/value","body":{"text":"johndoe"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.94/value","body":{"text":"johndoe"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.90/value","body":{"text":"johndoe"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.95"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@name='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.91"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.91/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.95/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.95/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.95/value","body":{"text":"123456"},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.91/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.91/value","body":{"text":"123456"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.95/value","body":{"text":"123456"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.91/value","body":{"text":"123456"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.92"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.96"}},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.92/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.96/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.92/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.96/property/value","body":{},"result":{"value":"Login"},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.92"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@class='submit-button btn_action']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.96"}},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.92/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.96/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.96/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.92/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"5","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-07-05T10:35:52.124Z","end":"2024-07-05T10:35:52.219Z","_duration":95,"uid":"caaab7aa-a64a-4e8e-9b2e-639f251b4928","cid":"0-0","title":"Then error popup displays \"Kamu belum registrasi bro!\"","fullTitle":"5: Then error popup displays \"Kamu belum registrasi bro!\"","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.103"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.99"}},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.99","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.99"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.103","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.103"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.103","ELEMENT":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.103"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.99","ELEMENT":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.99"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.103"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//h3[@data-test='error']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.99"}},"cid":"0-0","type":"result"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.99/text","body":{},"cid":"0-0","type":"command"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.103/text","body":{},"cid":"0-0","type":"command"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.D1612D7F22F974032D11C6F2A9D4C699.d.5C872AB528B03E7090A3926B3985404E.e.103/text","body":{},"result":{"value":"Epic sadface: Username and password do not match any user in this service"},"cid":"0-0","type":"result"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.CFFAE3A246AA67F5C05C837D5E1DBD0E.d.CF9D9C862AE4624D95441F020BA8CC79.e.99/text","body":{},"result":{"value":"Epic sadface: Username and password do not match any user in this service"},"cid":"0-0","type":"result"},{"command":"takeScreenshot","method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"cid":"0-0","type":"command"},{"command":"takeScreenshot","method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"cid":"0-0","type":"command"},{"command":"takeScreenshot","method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"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"},"cid":"0-0","type":"result"},{"command":"takeScreenshot","method":"GET","endpoint":"/session/:sessionId/screenshot","body":{},"result":{"value":"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JmxKROStzIffumpRyTHriqu++43Ezd6a3Lia3GtVVbwsuHjc49GfDxU9Pr9o3Iqxn+112Y9e+0pzrwUD+C6567PLA1Ndw53kK9el0AXzb2cPQWnbqgueCtErIkNue3v96DXOIiIvVJ7KjjPOlPHXfRtX1/xpXYxxpsiQo/13HfrVUZ6rqjNNncWGfffGDf/XVdFqW+YoCU6plquv+64//9Pl8lrEM295LuLOiQ1URKT/ZPUJXXr0ZyXBKdXjrjoXkXEXfV993Xf1Cb/00M5JDp+MFTzQ21bXPXt18ImR674nGvv4675dttYtL2XX2D2308uPHndklIu+8d0TFpsQor9yEV+ugFui50T7Xfq7p7qKOwmZ8sbc/kz5LTF8l5/xbPWjARcAgGmOTHmjmPvGbVFTmt121bmVbutUFQMAAG43MiVui2vdig8AAHxrcS8hAAAAaEWmBAAAgFZkSgAAAGhFpgQAAIBWZEoAAABoRaYEAACAVmRKAAAAaEWmBAAAgFZkSgAAAGhFpgQAAIBWZEoAAABoRaacZra2Oq02p9XmNFcmamzqBZPN2lqhoYFMU6eztURjFQAA4LuATDnN1JVk5GZn1HWrgcHRU13L7bR25zslWkMzAACYNsiU00yXubGpufEj1+BUF3JbGfOWPBkaNHuqywAAALcKmfKOEZtnOtVhc1ptzrPdp0z5sWNrYopNZttZm9Nqc542786L+dqmQZmmTueZ1qplQcMLjKlV73d6Jtk/MZuKF4175hsjTVkaFnz/Osoypla93/mJZ5P21qrk4S6umjevaLXZTOkiIlJyzGo7tTpM0UUVe2b5J51e39rq7DBljjy6omVj+jvmkYG0t5SODURi80ynTnt2V+exbanG4cXpuzuGTy0o3XncabU5rZ27X7iOYQIAAK9mTHUBuD4vmKpWz7u4vyxjf68EPL5+TXqVybEopdoukvLG1swIaasrMp12GRfnrF+9defZyFVNo1sGZZqaiyP6Tevisg55lsTsfLvoyRmWmuL6E+6gxWvSM0tN5+anVIpEb67euEh/eldRtaepxTqxeS8rquL1/ERDd83mXSfc+gVJa1MKqis+He3ommoLcy36J3KqfuqsLN71FxFxW296r6RtWhur66spfvOEO2jZurVpeSWVh/LtIsashrdXB9ubyjKO9s6au2L9c/m/V62PbrSI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MiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQDMoh0ZAAADFklEQVQAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAAQCsyJQAAALQiUwIAAEArMiUAAAC0IlMCAABAKzIlAAAAtCJTAgAA4P9vt44FAAAAAAb5Ww9ib1F0OSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAJdTAgBwOSUAAFeKcpqjyLmifwAAAABJRU5ErkJggg=="},"cid":"0-0","type":"result"},{"command":"deleteSession","method":"DELETE","endpoint":"/session/:sessionId","body":{},"cid":"0-0","type":"command"},{"command":"deleteSession","method":"DELETE","endpoint":"/session/:sessionId","body":{},"cid":"0-0","type":"command"},{"command":"deleteSession","method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"deleteSession","method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"5","state":"failed","errors":[{"name":"Error","message":"Error: \u001b[2mexpect(\u001b[22m\u001b[31mreceived\u001b[39m\u001b[2m).\u001b[22mtoBe\u001b[2m(\u001b[22m\u001b[32mexpected\u001b[39m\u001b[2m) // Object.is equality\u001b[22m","stack":"Error: \u001b[2mexpect(\u001b[22m\u001b[31mreceived\u001b[39m\u001b[2m).\u001b[22mtoBe\u001b[2m(\u001b[22m\u001b[32mexpected\u001b[39m\u001b[2m) // Object.is equality\u001b[22m\n\nExpected: \u001b[32m\"Kamu belum registrasi bro!\"\u001b[39m\nReceived: \u001b[31m\"Epic sadface: Username and password do not match any user in this service\"\u001b[39m\n    at LoginPage.validateErrorPopUpMessage (file:///D:/PERSONAL/LEARN/QA/github/wdio-cucumber1-ds4/features/pageobjects/login.page.js:43:41)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async World.<anonymous> (file:///D:/PERSONAL/LEARN/QA/github/wdio-cucumber1-ds4/features/step-definitions/steps.js:44:5)\n    at async wrapPromiseWithTimeout (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\time.js:57:12)\n    at async Object.run (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\user_code_runner.js:64:22)\n    at async Object.run (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\step_runner.js:51:26)\n    at async TestCaseRunner.invokeStep (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:95:16)\n    at async TestCaseRunner.runStep (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:244:26)\n    at async D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:175:44\n    at async TestCaseRunner.aroundTestStep (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:120:32)"}],"error":{"name":"Error","message":"Error: \u001b[2mexpect(\u001b[22m\u001b[31mreceived\u001b[39m\u001b[2m).\u001b[22mtoBe\u001b[2m(\u001b[22m\u001b[32mexpected\u001b[39m\u001b[2m) // Object.is equality\u001b[22m","stack":"Error: \u001b[2mexpect(\u001b[22m\u001b[31mreceived\u001b[39m\u001b[2m).\u001b[22mtoBe\u001b[2m(\u001b[22m\u001b[32mexpected\u001b[39m\u001b[2m) // Object.is equality\u001b[22m\n\nExpected: \u001b[32m\"Kamu belum registrasi bro!\"\u001b[39m\nReceived: \u001b[31m\"Epic sadface: Username and password do not match any user in this service\"\u001b[39m\n    at LoginPage.validateErrorPopUpMessage (file:///D:/PERSONAL/LEARN/QA/github/wdio-cucumber1-ds4/features/pageobjects/login.page.js:43:41)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async World.<anonymous> (file:///D:/PERSONAL/LEARN/QA/github/wdio-cucumber1-ds4/features/step-definitions/steps.js:44:5)\n    at async wrapPromiseWithTimeout (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\time.js:57:12)\n    at async Object.run (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\user_code_runner.js:64:22)\n    at async Object.run (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\step_runner.js:51:26)\n    at async TestCaseRunner.invokeStep (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:95:16)\n    at async TestCaseRunner.runStep (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:244:26)\n    at async D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:175:44\n    at async TestCaseRunner.aroundTestStep (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:120:32)"},"events":[{"type":"Error","value":{"name":"Error","message":"Error: \u001b[2mexpect(\u001b[22m\u001b[31mreceived\u001b[39m\u001b[2m).\u001b[22mtoBe\u001b[2m(\u001b[22m\u001b[32mexpected\u001b[39m\u001b[2m) // Object.is equality\u001b[22m","stack":"Error: \u001b[2mexpect(\u001b[22m\u001b[31mreceived\u001b[39m\u001b[2m).\u001b[22mtoBe\u001b[2m(\u001b[22m\u001b[32mexpected\u001b[39m\u001b[2m) // Object.is equality\u001b[22m\n\nExpected: \u001b[32m\"Kamu belum registrasi bro!\"\u001b[39m\nReceived: \u001b[31m\"Epic sadface: Username and password do not match any user in this service\"\u001b[39m\n    at LoginPage.validateErrorPopUpMessage (file:///D:/PERSONAL/LEARN/QA/github/wdio-cucumber1-ds4/features/pageobjects/login.page.js:43:41)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async World.<anonymous> (file:///D:/PERSONAL/LEARN/QA/github/wdio-cucumber1-ds4/features/step-definitions/steps.js:44:5)\n    at async wrapPromiseWithTimeout (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\time.js:57:12)\n    at async Object.run (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\user_code_runner.js:64:22)\n    at async Object.run (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\step_runner.js:51:26)\n    at async TestCaseRunner.invokeStep (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:95:16)\n    at async TestCaseRunner.runStep (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:244:26)\n    at async D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:175:44\n    at async TestCaseRunner.aroundTestStep (D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\node_modules\\@cucumber\\cucumber\\lib\\runtime\\test_case_runner.js:120:32)"}}],"errorIndex":1},{"type":"hook","start":"2024-07-05T10:35:52.220Z","end":"2024-07-05T10:35:52.354Z","_duration":134,"uid":"b799f342-2723-4767-989b-035ecf8f8e2b","cid":"0-0","title":"","parent":"5","errors":[]}],"description":""}],"hooksAndTests":[],"description":""}],"reportFile":"D:\\PERSONAL\\LEARN\\QA\\github\\wdio-cucumber1-ds4\\reports\\html\\html-report-2024-07-05_17-35-33\\master-report-cb67a19e-59fb-4c99-94f2-2a0a22f0f9b5-0-0.html","browserName":"Chrome & Edge"}